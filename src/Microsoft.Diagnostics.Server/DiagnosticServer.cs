using System;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Diagnostics.EventPipe.Protocol;

namespace Microsoft.Diagnostics.Server
{
    public class DiagnosticServer : IDisposable
    {
        private readonly IPEndPoint _endPoint;
        private TcpListener _listener;
        private readonly CancellationTokenSource _shutdownCts = new CancellationTokenSource();
        private IDisposable _registration;

        private DiagnosticServer(IPEndPoint endPoint)
        {
            _endPoint = endPoint;
            _listener = new TcpListener(endPoint);
        }

        /// <summary>
        /// Starts the diagnostic server on any free port and registers that port with the list of available
        /// processes to monitor.
        /// </summary>
        /// <remarks>
        /// It's not critical to await this task. If not awaited, it's possible events generated by application start-up
        /// won't be available.
        /// </remarks>
        /// <returns></returns>
        public static Task<DiagnosticServer> StartAsync() => StartAsync(new IPEndPoint(IPAddress.Loopback, 0));

        /// <summary>
        /// Starts the diagnostic server on the specified endpoint.
        /// </summary>
        /// <remarks>
        /// <para>
        /// If the endpoint binds to localhost, the process will be registered in the list of local proceses.
        /// </para>
        /// <para>
        /// It's not critical to await this task. If not awaited, it's possible events generated by application start-up
        /// won't be available.
        /// </para>
        /// </remarks>
        /// <returns></returns>
        public static async Task<DiagnosticServer> StartAsync(IPEndPoint endPoint)
        {
            var server = new DiagnosticServer(endPoint);
            await server.StartListeningAsync();
            return server;
        }

        public void Dispose()
        {
            _shutdownCts.Cancel();
            _registration?.Dispose();
        }

        private async Task StartListeningAsync()
        {
            _listener.Start();

            if(_listener.LocalEndpoint is IPEndPoint ipep && IPAddress.IsLoopback(ipep.Address))
            {
                var p = Process.GetCurrentProcess();
                _registration = await ProcessLocator.RegisterProcessAsync(new ProcessRegistration(
                    p.Id,
                    ipep.Port,
                    p.MainModule.ModuleName,
                    Environment.CommandLine,
                    protocolVersion: 1));
                Trace("Registered with Process List");
            }

            _ = AcceptLoop(_listener, _shutdownCts.Token);
        }

        private async Task AcceptLoop(TcpListener listener, CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                var client = await listener.AcceptTcpClientAsync();
                Trace("Accepted socket");

                var pipe = client.GetStream().CreatePipe();
                var server = new EventPipeServer(pipe);
                _ = server.RunAsync();
            }
        }

        private static void Trace(string line)
        {
            // Cheap-n-dirty logging :)
            Console.WriteLine($"[DiagnosticServer] {line}");
        }
    }
}
